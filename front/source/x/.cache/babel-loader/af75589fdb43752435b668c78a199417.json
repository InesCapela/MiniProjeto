{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar Transport = require('../transport');\n\nvar parseqs = require('parseqs');\n\nvar parser = require('engine.io-parser');\n\nvar inherit = require('component-inherit');\n\nvar yeast = require('yeast');\n\nvar debug = require('debug')('engine.io-client:polling');\n/**\n * Module exports.\n */\n\n\nmodule.exports = Polling;\n/**\n * Is XHR2 supported?\n */\n\nvar hasXHR2 = function () {\n  var XMLHttpRequest = require('xmlhttprequest-ssl');\n\n  var xhr = new XMLHttpRequest({\n    xdomain: false\n  });\n  return null != xhr.responseType;\n}();\n/**\n * Polling interface.\n *\n * @param {Object} opts\n * @api private\n */\n\n\nfunction Polling(opts) {\n  var forceBase64 = opts && opts.forceBase64;\n\n  if (!hasXHR2 || forceBase64) {\n    this.supportsBinary = false;\n  }\n\n  Transport.call(this, opts);\n}\n/**\n * Inherits from Transport.\n */\n\n\ninherit(Polling, Transport);\n/**\n * Transport name.\n */\n\nPolling.prototype.name = 'polling';\n/**\n * Opens the socket (triggers polling). We write a PING message to determine\n * when the transport is open.\n *\n * @api private\n */\n\nPolling.prototype.doOpen = function () {\n  this.poll();\n};\n/**\n * Pauses polling.\n *\n * @param {Function} callback upon buffers are flushed and transport is paused\n * @api private\n */\n\n\nPolling.prototype.pause = function (onPause) {\n  var pending = 0;\n  var self = this;\n  this.readyState = 'pausing';\n\n  function pause() {\n    debug('paused');\n    self.readyState = 'paused';\n    onPause();\n  }\n\n  if (this.polling || !this.writable) {\n    var total = 0;\n\n    if (this.polling) {\n      debug('we are currently polling - waiting to pause');\n      total++;\n      this.once('pollComplete', function () {\n        debug('pre-pause polling complete');\n        --total || pause();\n      });\n    }\n\n    if (!this.writable) {\n      debug('we are currently writing - waiting to pause');\n      total++;\n      this.once('drain', function () {\n        debug('pre-pause writing complete');\n        --total || pause();\n      });\n    }\n  } else {\n    pause();\n  }\n};\n/**\n * Starts polling cycle.\n *\n * @api public\n */\n\n\nPolling.prototype.poll = function () {\n  debug('polling');\n  this.polling = true;\n  this.doPoll();\n  this.emit('poll');\n};\n/**\n * Overloads onData to detect payloads.\n *\n * @api private\n */\n\n\nPolling.prototype.onData = function (data) {\n  var self = this;\n  debug('polling got data %s', data);\n\n  var callback = function (packet, index, total) {\n    // if its the first message we consider the transport open\n    if ('opening' == self.readyState) {\n      self.onOpen();\n    } // if its a close packet, we close the ongoing requests\n\n\n    if ('close' == packet.type) {\n      self.onClose();\n      return false;\n    } // otherwise bypass onData and handle the message\n\n\n    self.onPacket(packet);\n  }; // decode payload\n\n\n  parser.decodePayload(data, this.socket.binaryType, callback); // if an event did not trigger closing\n\n  if ('closed' != this.readyState) {\n    // if we got data we're not polling\n    this.polling = false;\n    this.emit('pollComplete');\n\n    if ('open' == this.readyState) {\n      this.poll();\n    } else {\n      debug('ignoring poll - transport state \"%s\"', this.readyState);\n    }\n  }\n};\n/**\n * For polling, send a close packet.\n *\n * @api private\n */\n\n\nPolling.prototype.doClose = function () {\n  var self = this;\n\n  function close() {\n    debug('writing close packet');\n    self.write([{\n      type: 'close'\n    }]);\n  }\n\n  if ('open' == this.readyState) {\n    debug('transport open - closing');\n    close();\n  } else {\n    // in case we're trying to close while\n    // handshaking is in progress (GH-164)\n    debug('transport not open - deferring close');\n    this.once('open', close);\n  }\n};\n/**\n * Writes a packets payload.\n *\n * @param {Array} data packets\n * @param {Function} drain callback\n * @api private\n */\n\n\nPolling.prototype.write = function (packets) {\n  var self = this;\n  this.writable = false;\n\n  var callbackfn = function () {\n    self.writable = true;\n    self.emit('drain');\n  };\n\n  var self = this;\n  parser.encodePayload(packets, this.supportsBinary, function (data) {\n    self.doWrite(data, callbackfn);\n  });\n};\n/**\n * Generates uri for connection.\n *\n * @api private\n */\n\n\nPolling.prototype.uri = function () {\n  var query = this.query || {};\n  var schema = this.secure ? 'https' : 'http';\n  var port = ''; // cache busting is forced\n\n  if (false !== this.timestampRequests) {\n    query[this.timestampParam] = yeast();\n  }\n\n  if (!this.supportsBinary && !query.sid) {\n    query.b64 = 1;\n  }\n\n  query = parseqs.encode(query); // avoid port if default for schema\n\n  if (this.port && ('https' == schema && this.port != 443 || 'http' == schema && this.port != 80)) {\n    port = ':' + this.port;\n  } // prepend ? to query\n\n\n  if (query.length) {\n    query = '?' + query;\n  }\n\n  var ipv6 = this.hostname.indexOf(':') !== -1;\n  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;\n};","map":{"version":3,"sources":["/app/node_modules/engine.io-client/lib/transports/polling.js"],"names":["Transport","require","parseqs","parser","inherit","yeast","debug","module","exports","Polling","hasXHR2","XMLHttpRequest","xhr","xdomain","responseType","opts","forceBase64","supportsBinary","call","prototype","name","doOpen","poll","pause","onPause","pending","self","readyState","polling","writable","total","once","doPoll","emit","onData","data","callback","packet","index","onOpen","type","onClose","onPacket","decodePayload","socket","binaryType","doClose","close","write","packets","callbackfn","encodePayload","doWrite","uri","query","schema","secure","port","timestampRequests","timestampParam","sid","b64","encode","length","ipv6","hostname","indexOf","path"],"mappings":"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","sourcesContent":["/**\n * Module dependencies.\n */\n\nvar Transport = require('../transport');\nvar parseqs = require('parseqs');\nvar parser = require('engine.io-parser');\nvar inherit = require('component-inherit');\nvar yeast = require('yeast');\nvar debug = require('debug')('engine.io-client:polling');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Polling;\n\n/**\n * Is XHR2 supported?\n */\n\nvar hasXHR2 = (function() {\n  var XMLHttpRequest = require('xmlhttprequest-ssl');\n  var xhr = new XMLHttpRequest({ xdomain: false });\n  return null != xhr.responseType;\n})();\n\n/**\n * Polling interface.\n *\n * @param {Object} opts\n * @api private\n */\n\nfunction Polling(opts){\n  var forceBase64 = (opts && opts.forceBase64);\n  if (!hasXHR2 || forceBase64) {\n    this.supportsBinary = false;\n  }\n  Transport.call(this, opts);\n}\n\n/**\n * Inherits from Transport.\n */\n\ninherit(Polling, Transport);\n\n/**\n * Transport name.\n */\n\nPolling.prototype.name = 'polling';\n\n/**\n * Opens the socket (triggers polling). We write a PING message to determine\n * when the transport is open.\n *\n * @api private\n */\n\nPolling.prototype.doOpen = function(){\n  this.poll();\n};\n\n/**\n * Pauses polling.\n *\n * @param {Function} callback upon buffers are flushed and transport is paused\n * @api private\n */\n\nPolling.prototype.pause = function(onPause){\n  var pending = 0;\n  var self = this;\n\n  this.readyState = 'pausing';\n\n  function pause(){\n    debug('paused');\n    self.readyState = 'paused';\n    onPause();\n  }\n\n  if (this.polling || !this.writable) {\n    var total = 0;\n\n    if (this.polling) {\n      debug('we are currently polling - waiting to pause');\n      total++;\n      this.once('pollComplete', function(){\n        debug('pre-pause polling complete');\n        --total || pause();\n      });\n    }\n\n    if (!this.writable) {\n      debug('we are currently writing - waiting to pause');\n      total++;\n      this.once('drain', function(){\n        debug('pre-pause writing complete');\n        --total || pause();\n      });\n    }\n  } else {\n    pause();\n  }\n};\n\n/**\n * Starts polling cycle.\n *\n * @api public\n */\n\nPolling.prototype.poll = function(){\n  debug('polling');\n  this.polling = true;\n  this.doPoll();\n  this.emit('poll');\n};\n\n/**\n * Overloads onData to detect payloads.\n *\n * @api private\n */\n\nPolling.prototype.onData = function(data){\n  var self = this;\n  debug('polling got data %s', data);\n  var callback = function(packet, index, total) {\n    // if its the first message we consider the transport open\n    if ('opening' == self.readyState) {\n      self.onOpen();\n    }\n\n    // if its a close packet, we close the ongoing requests\n    if ('close' == packet.type) {\n      self.onClose();\n      return false;\n    }\n\n    // otherwise bypass onData and handle the message\n    self.onPacket(packet);\n  };\n\n  // decode payload\n  parser.decodePayload(data, this.socket.binaryType, callback);\n\n  // if an event did not trigger closing\n  if ('closed' != this.readyState) {\n    // if we got data we're not polling\n    this.polling = false;\n    this.emit('pollComplete');\n\n    if ('open' == this.readyState) {\n      this.poll();\n    } else {\n      debug('ignoring poll - transport state \"%s\"', this.readyState);\n    }\n  }\n};\n\n/**\n * For polling, send a close packet.\n *\n * @api private\n */\n\nPolling.prototype.doClose = function(){\n  var self = this;\n\n  function close(){\n    debug('writing close packet');\n    self.write([{ type: 'close' }]);\n  }\n\n  if ('open' == this.readyState) {\n    debug('transport open - closing');\n    close();\n  } else {\n    // in case we're trying to close while\n    // handshaking is in progress (GH-164)\n    debug('transport not open - deferring close');\n    this.once('open', close);\n  }\n};\n\n/**\n * Writes a packets payload.\n *\n * @param {Array} data packets\n * @param {Function} drain callback\n * @api private\n */\n\nPolling.prototype.write = function(packets){\n  var self = this;\n  this.writable = false;\n  var callbackfn = function() {\n    self.writable = true;\n    self.emit('drain');\n  };\n\n  var self = this;\n  parser.encodePayload(packets, this.supportsBinary, function(data) {\n    self.doWrite(data, callbackfn);\n  });\n};\n\n/**\n * Generates uri for connection.\n *\n * @api private\n */\n\nPolling.prototype.uri = function(){\n  var query = this.query || {};\n  var schema = this.secure ? 'https' : 'http';\n  var port = '';\n\n  // cache busting is forced\n  if (false !== this.timestampRequests) {\n    query[this.timestampParam] = yeast();\n  }\n\n  if (!this.supportsBinary && !query.sid) {\n    query.b64 = 1;\n  }\n\n  query = parseqs.encode(query);\n\n  // avoid port if default for schema\n  if (this.port && (('https' == schema && this.port != 443) ||\n     ('http' == schema && this.port != 80))) {\n    port = ':' + this.port;\n  }\n\n  // prepend ? to query\n  if (query.length) {\n    query = '?' + query;\n  }\n\n  var ipv6 = this.hostname.indexOf(':') !== -1;\n  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;\n};\n"]},"metadata":{},"sourceType":"script"}