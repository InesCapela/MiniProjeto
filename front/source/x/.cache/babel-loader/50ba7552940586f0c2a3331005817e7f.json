{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar parser = require('socket.io-parser');\n\nvar Emitter = require('component-emitter');\n\nvar toArray = require('to-array');\n\nvar on = require('./on');\n\nvar bind = require('component-bind');\n\nvar debug = require('debug')('socket.io-client:socket');\n\nvar hasBin = require('has-binary');\n/**\n * Module exports.\n */\n\n\nmodule.exports = exports = Socket;\n/**\n * Internal events (blacklisted).\n * These events can't be emitted by the user.\n *\n * @api private\n */\n\nvar events = {\n  connect: 1,\n  connect_error: 1,\n  connect_timeout: 1,\n  connecting: 1,\n  disconnect: 1,\n  error: 1,\n  reconnect: 1,\n  reconnect_attempt: 1,\n  reconnect_failed: 1,\n  reconnect_error: 1,\n  reconnecting: 1,\n  ping: 1,\n  pong: 1\n};\n/**\n * Shortcut to `Emitter#emit`.\n */\n\nvar emit = Emitter.prototype.emit;\n/**\n * `Socket` constructor.\n *\n * @api public\n */\n\nfunction Socket(io, nsp) {\n  this.io = io;\n  this.nsp = nsp;\n  this.json = this; // compat\n\n  this.ids = 0;\n  this.acks = {};\n  this.receiveBuffer = [];\n  this.sendBuffer = [];\n  this.connected = false;\n  this.disconnected = true;\n  if (this.io.autoConnect) this.open();\n}\n/**\n * Mix in `Emitter`.\n */\n\n\nEmitter(Socket.prototype);\n/**\n * Subscribe to open, close and packet events\n *\n * @api private\n */\n\nSocket.prototype.subEvents = function () {\n  if (this.subs) return;\n  var io = this.io;\n  this.subs = [on(io, 'open', bind(this, 'onopen')), on(io, 'packet', bind(this, 'onpacket')), on(io, 'close', bind(this, 'onclose'))];\n};\n/**\n * \"Opens\" the socket.\n *\n * @api public\n */\n\n\nSocket.prototype.open = Socket.prototype.connect = function () {\n  if (this.connected) return this;\n  this.subEvents();\n  this.io.open(); // ensure open\n\n  if ('open' == this.io.readyState) this.onopen();\n  this.emit('connecting');\n  return this;\n};\n/**\n * Sends a `message` event.\n *\n * @return {Socket} self\n * @api public\n */\n\n\nSocket.prototype.send = function () {\n  var args = toArray(arguments);\n  args.unshift('message');\n  this.emit.apply(this, args);\n  return this;\n};\n/**\n * Override `emit`.\n * If the event is in `events`, it's emitted normally.\n *\n * @param {String} event name\n * @return {Socket} self\n * @api public\n */\n\n\nSocket.prototype.emit = function (ev) {\n  if (events.hasOwnProperty(ev)) {\n    emit.apply(this, arguments);\n    return this;\n  }\n\n  var args = toArray(arguments);\n  var parserType = parser.EVENT; // default\n\n  if (hasBin(args)) {\n    parserType = parser.BINARY_EVENT;\n  } // binary\n\n\n  var packet = {\n    type: parserType,\n    data: args\n  };\n  packet.options = {};\n  packet.options.compress = !this.flags || false !== this.flags.compress; // event ack callback\n\n  if ('function' == typeof args[args.length - 1]) {\n    debug('emitting packet with ack id %d', this.ids);\n    this.acks[this.ids] = args.pop();\n    packet.id = this.ids++;\n  }\n\n  if (this.connected) {\n    this.packet(packet);\n  } else {\n    this.sendBuffer.push(packet);\n  }\n\n  delete this.flags;\n  return this;\n};\n/**\n * Sends a packet.\n *\n * @param {Object} packet\n * @api private\n */\n\n\nSocket.prototype.packet = function (packet) {\n  packet.nsp = this.nsp;\n  this.io.packet(packet);\n};\n/**\n * Called upon engine `open`.\n *\n * @api private\n */\n\n\nSocket.prototype.onopen = function () {\n  debug('transport is open - connecting'); // write connect packet if necessary\n\n  if ('/' != this.nsp) {\n    this.packet({\n      type: parser.CONNECT\n    });\n  }\n};\n/**\n * Called upon engine `close`.\n *\n * @param {String} reason\n * @api private\n */\n\n\nSocket.prototype.onclose = function (reason) {\n  debug('close (%s)', reason);\n  this.connected = false;\n  this.disconnected = true;\n  delete this.id;\n  this.emit('disconnect', reason);\n};\n/**\n * Called with socket packet.\n *\n * @param {Object} packet\n * @api private\n */\n\n\nSocket.prototype.onpacket = function (packet) {\n  if (packet.nsp != this.nsp) return;\n\n  switch (packet.type) {\n    case parser.CONNECT:\n      this.onconnect();\n      break;\n\n    case parser.EVENT:\n      this.onevent(packet);\n      break;\n\n    case parser.BINARY_EVENT:\n      this.onevent(packet);\n      break;\n\n    case parser.ACK:\n      this.onack(packet);\n      break;\n\n    case parser.BINARY_ACK:\n      this.onack(packet);\n      break;\n\n    case parser.DISCONNECT:\n      this.ondisconnect();\n      break;\n\n    case parser.ERROR:\n      this.emit('error', packet.data);\n      break;\n  }\n};\n/**\n * Called upon a server event.\n *\n * @param {Object} packet\n * @api private\n */\n\n\nSocket.prototype.onevent = function (packet) {\n  var args = packet.data || [];\n  debug('emitting event %j', args);\n\n  if (null != packet.id) {\n    debug('attaching ack callback to event');\n    args.push(this.ack(packet.id));\n  }\n\n  if (this.connected) {\n    emit.apply(this, args);\n  } else {\n    this.receiveBuffer.push(args);\n  }\n};\n/**\n * Produces an ack callback to emit with an event.\n *\n * @api private\n */\n\n\nSocket.prototype.ack = function (id) {\n  var self = this;\n  var sent = false;\n  return function () {\n    // prevent double callbacks\n    if (sent) return;\n    sent = true;\n    var args = toArray(arguments);\n    debug('sending ack %j', args);\n    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;\n    self.packet({\n      type: type,\n      id: id,\n      data: args\n    });\n  };\n};\n/**\n * Called upon a server acknowlegement.\n *\n * @param {Object} packet\n * @api private\n */\n\n\nSocket.prototype.onack = function (packet) {\n  var ack = this.acks[packet.id];\n\n  if ('function' == typeof ack) {\n    debug('calling ack %s with %j', packet.id, packet.data);\n    ack.apply(this, packet.data);\n    delete this.acks[packet.id];\n  } else {\n    debug('bad ack %s', packet.id);\n  }\n};\n/**\n * Called upon server connect.\n *\n * @api private\n */\n\n\nSocket.prototype.onconnect = function () {\n  this.connected = true;\n  this.disconnected = false;\n  this.emit('connect');\n  this.emitBuffered();\n};\n/**\n * Emit buffered events (received and emitted).\n *\n * @api private\n */\n\n\nSocket.prototype.emitBuffered = function () {\n  var i;\n\n  for (i = 0; i < this.receiveBuffer.length; i++) {\n    emit.apply(this, this.receiveBuffer[i]);\n  }\n\n  this.receiveBuffer = [];\n\n  for (i = 0; i < this.sendBuffer.length; i++) {\n    this.packet(this.sendBuffer[i]);\n  }\n\n  this.sendBuffer = [];\n};\n/**\n * Called upon server disconnect.\n *\n * @api private\n */\n\n\nSocket.prototype.ondisconnect = function () {\n  debug('server disconnect (%s)', this.nsp);\n  this.destroy();\n  this.onclose('io server disconnect');\n};\n/**\n * Called upon forced client/server side disconnections,\n * this method ensures the manager stops tracking us and\n * that reconnections don't get triggered for this.\n *\n * @api private.\n */\n\n\nSocket.prototype.destroy = function () {\n  if (this.subs) {\n    // clean subscriptions to avoid reconnections\n    for (var i = 0; i < this.subs.length; i++) {\n      this.subs[i].destroy();\n    }\n\n    this.subs = null;\n  }\n\n  this.io.destroy(this);\n};\n/**\n * Disconnects the socket manually.\n *\n * @return {Socket} self\n * @api public\n */\n\n\nSocket.prototype.close = Socket.prototype.disconnect = function () {\n  if (this.connected) {\n    debug('performing disconnect (%s)', this.nsp);\n    this.packet({\n      type: parser.DISCONNECT\n    });\n  } // remove socket from pool\n\n\n  this.destroy();\n\n  if (this.connected) {\n    // fire events\n    this.onclose('io client disconnect');\n  }\n\n  return this;\n};\n/**\n * Sets the compress flag.\n *\n * @param {Boolean} if `true`, compresses the sending data\n * @return {Socket} self\n * @api public\n */\n\n\nSocket.prototype.compress = function (compress) {\n  this.flags = this.flags || {};\n  this.flags.compress = compress;\n  return this;\n};","map":{"version":3,"sources":["/app/node_modules/socket.io-client/lib/socket.js"],"names":["parser","require","Emitter","toArray","on","bind","debug","hasBin","module","exports","Socket","events","connect","connect_error","connect_timeout","connecting","disconnect","error","reconnect","reconnect_attempt","reconnect_failed","reconnect_error","reconnecting","ping","pong","emit","prototype","io","nsp","json","ids","acks","receiveBuffer","sendBuffer","connected","disconnected","autoConnect","open","subEvents","subs","readyState","onopen","send","args","arguments","unshift","apply","ev","hasOwnProperty","parserType","EVENT","BINARY_EVENT","packet","type","data","options","compress","flags","length","pop","id","push","CONNECT","onclose","reason","onpacket","onconnect","onevent","ACK","onack","BINARY_ACK","DISCONNECT","ondisconnect","ERROR","ack","self","sent","emitBuffered","i","destroy","close"],"mappings":"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","sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar parser = require('socket.io-parser');\nvar Emitter = require('component-emitter');\nvar toArray = require('to-array');\nvar on = require('./on');\nvar bind = require('component-bind');\nvar debug = require('debug')('socket.io-client:socket');\nvar hasBin = require('has-binary');\n\n/**\n * Module exports.\n */\n\nmodule.exports = exports = Socket;\n\n/**\n * Internal events (blacklisted).\n * These events can't be emitted by the user.\n *\n * @api private\n */\n\nvar events = {\n  connect: 1,\n  connect_error: 1,\n  connect_timeout: 1,\n  connecting: 1,\n  disconnect: 1,\n  error: 1,\n  reconnect: 1,\n  reconnect_attempt: 1,\n  reconnect_failed: 1,\n  reconnect_error: 1,\n  reconnecting: 1,\n  ping: 1,\n  pong: 1\n};\n\n/**\n * Shortcut to `Emitter#emit`.\n */\n\nvar emit = Emitter.prototype.emit;\n\n/**\n * `Socket` constructor.\n *\n * @api public\n */\n\nfunction Socket(io, nsp){\n  this.io = io;\n  this.nsp = nsp;\n  this.json = this; // compat\n  this.ids = 0;\n  this.acks = {};\n  this.receiveBuffer = [];\n  this.sendBuffer = [];\n  this.connected = false;\n  this.disconnected = true;\n  if (this.io.autoConnect) this.open();\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Socket.prototype);\n\n/**\n * Subscribe to open, close and packet events\n *\n * @api private\n */\n\nSocket.prototype.subEvents = function() {\n  if (this.subs) return;\n\n  var io = this.io;\n  this.subs = [\n    on(io, 'open', bind(this, 'onopen')),\n    on(io, 'packet', bind(this, 'onpacket')),\n    on(io, 'close', bind(this, 'onclose'))\n  ];\n};\n\n/**\n * \"Opens\" the socket.\n *\n * @api public\n */\n\nSocket.prototype.open =\nSocket.prototype.connect = function(){\n  if (this.connected) return this;\n\n  this.subEvents();\n  this.io.open(); // ensure open\n  if ('open' == this.io.readyState) this.onopen();\n  this.emit('connecting');\n  return this;\n};\n\n/**\n * Sends a `message` event.\n *\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.send = function(){\n  var args = toArray(arguments);\n  args.unshift('message');\n  this.emit.apply(this, args);\n  return this;\n};\n\n/**\n * Override `emit`.\n * If the event is in `events`, it's emitted normally.\n *\n * @param {String} event name\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.emit = function(ev){\n  if (events.hasOwnProperty(ev)) {\n    emit.apply(this, arguments);\n    return this;\n  }\n\n  var args = toArray(arguments);\n  var parserType = parser.EVENT; // default\n  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary\n  var packet = { type: parserType, data: args };\n\n  packet.options = {};\n  packet.options.compress = !this.flags || false !== this.flags.compress;\n\n  // event ack callback\n  if ('function' == typeof args[args.length - 1]) {\n    debug('emitting packet with ack id %d', this.ids);\n    this.acks[this.ids] = args.pop();\n    packet.id = this.ids++;\n  }\n\n  if (this.connected) {\n    this.packet(packet);\n  } else {\n    this.sendBuffer.push(packet);\n  }\n\n  delete this.flags;\n\n  return this;\n};\n\n/**\n * Sends a packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.packet = function(packet){\n  packet.nsp = this.nsp;\n  this.io.packet(packet);\n};\n\n/**\n * Called upon engine `open`.\n *\n * @api private\n */\n\nSocket.prototype.onopen = function(){\n  debug('transport is open - connecting');\n\n  // write connect packet if necessary\n  if ('/' != this.nsp) {\n    this.packet({ type: parser.CONNECT });\n  }\n};\n\n/**\n * Called upon engine `close`.\n *\n * @param {String} reason\n * @api private\n */\n\nSocket.prototype.onclose = function(reason){\n  debug('close (%s)', reason);\n  this.connected = false;\n  this.disconnected = true;\n  delete this.id;\n  this.emit('disconnect', reason);\n};\n\n/**\n * Called with socket packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onpacket = function(packet){\n  if (packet.nsp != this.nsp) return;\n\n  switch (packet.type) {\n    case parser.CONNECT:\n      this.onconnect();\n      break;\n\n    case parser.EVENT:\n      this.onevent(packet);\n      break;\n\n    case parser.BINARY_EVENT:\n      this.onevent(packet);\n      break;\n\n    case parser.ACK:\n      this.onack(packet);\n      break;\n\n    case parser.BINARY_ACK:\n      this.onack(packet);\n      break;\n\n    case parser.DISCONNECT:\n      this.ondisconnect();\n      break;\n\n    case parser.ERROR:\n      this.emit('error', packet.data);\n      break;\n  }\n};\n\n/**\n * Called upon a server event.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onevent = function(packet){\n  var args = packet.data || [];\n  debug('emitting event %j', args);\n\n  if (null != packet.id) {\n    debug('attaching ack callback to event');\n    args.push(this.ack(packet.id));\n  }\n\n  if (this.connected) {\n    emit.apply(this, args);\n  } else {\n    this.receiveBuffer.push(args);\n  }\n};\n\n/**\n * Produces an ack callback to emit with an event.\n *\n * @api private\n */\n\nSocket.prototype.ack = function(id){\n  var self = this;\n  var sent = false;\n  return function(){\n    // prevent double callbacks\n    if (sent) return;\n    sent = true;\n    var args = toArray(arguments);\n    debug('sending ack %j', args);\n\n    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;\n    self.packet({\n      type: type,\n      id: id,\n      data: args\n    });\n  };\n};\n\n/**\n * Called upon a server acknowlegement.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onack = function(packet){\n  var ack = this.acks[packet.id];\n  if ('function' == typeof ack) {\n    debug('calling ack %s with %j', packet.id, packet.data);\n    ack.apply(this, packet.data);\n    delete this.acks[packet.id];\n  } else {\n    debug('bad ack %s', packet.id);\n  }\n};\n\n/**\n * Called upon server connect.\n *\n * @api private\n */\n\nSocket.prototype.onconnect = function(){\n  this.connected = true;\n  this.disconnected = false;\n  this.emit('connect');\n  this.emitBuffered();\n};\n\n/**\n * Emit buffered events (received and emitted).\n *\n * @api private\n */\n\nSocket.prototype.emitBuffered = function(){\n  var i;\n  for (i = 0; i < this.receiveBuffer.length; i++) {\n    emit.apply(this, this.receiveBuffer[i]);\n  }\n  this.receiveBuffer = [];\n\n  for (i = 0; i < this.sendBuffer.length; i++) {\n    this.packet(this.sendBuffer[i]);\n  }\n  this.sendBuffer = [];\n};\n\n/**\n * Called upon server disconnect.\n *\n * @api private\n */\n\nSocket.prototype.ondisconnect = function(){\n  debug('server disconnect (%s)', this.nsp);\n  this.destroy();\n  this.onclose('io server disconnect');\n};\n\n/**\n * Called upon forced client/server side disconnections,\n * this method ensures the manager stops tracking us and\n * that reconnections don't get triggered for this.\n *\n * @api private.\n */\n\nSocket.prototype.destroy = function(){\n  if (this.subs) {\n    // clean subscriptions to avoid reconnections\n    for (var i = 0; i < this.subs.length; i++) {\n      this.subs[i].destroy();\n    }\n    this.subs = null;\n  }\n\n  this.io.destroy(this);\n};\n\n/**\n * Disconnects the socket manually.\n *\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.close =\nSocket.prototype.disconnect = function(){\n  if (this.connected) {\n    debug('performing disconnect (%s)', this.nsp);\n    this.packet({ type: parser.DISCONNECT });\n  }\n\n  // remove socket from pool\n  this.destroy();\n\n  if (this.connected) {\n    // fire events\n    this.onclose('io client disconnect');\n  }\n  return this;\n};\n\n/**\n * Sets the compress flag.\n *\n * @param {Boolean} if `true`, compresses the sending data\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.compress = function(compress){\n  this.flags = this.flags || {};\n  this.flags.compress = compress;\n  return this;\n};\n"]},"metadata":{},"sourceType":"script"}